---
layout: post
subclass: post
title: "운영체제 (2) 프로세스"
date: 2018-09-17 00:00:02
tags: [dudaji, computer-science, operating_system]
excerpt: "운영체제 Process에 대한 정리입니다."
disqus: True
---

## 프로세스란?

프로세스란 '수행 중인 프로그램(program in execution)'이다.
여기서 프로세스(process)와 프로그램(program)은 구분할 필요가 있다.

### 프로세스 vs 프로그램

프로그램 : 디스크에 저장된 실행파일로서 수동적인 개체
프로세스 : 메모리에 적재되어 문맥(context)를 가지는 능동적인 개체

## 문맥(context)이란?

프로세스가 문맥(context)를 가지는 능동적인 개체라면 문맥은 무엇일까?

문맥 : 프로세스가 현재 어떤 상태에서 수행되고 있는지를 정확히 규명하기 위해
필요한 정보

### 왜 문맥(context)이라는 개념이 필요할까?

시분할(time sharing) 시스템 환경에서는 프로세스가 인터럽트(interrupt)에 의해 CPU를 선점당했다가 다시 점유하는 식으로 진행된다.

그런데 인터럽트로 CPU의 제어권이 다른 프로세스로 넘어가면 기존에 CPU 내의 레지스터에 있던 값들은 지워지게 된다.
=> 그러므로 어떻게 프로세스가 수행되고 있었는지 수행시점의 상태를 나타내는 정보를 저장하고 복원하는 것이 중요한데 이 정보를 '문맥'이라고 한다.

### 문맥의 분류

문맥을 나누어 본다면 크게 3가지로 나누어 볼 수 있다.

- 하드웨어 문맥
- 프로세스의 주소공간
- 커널(kernel) 상의 문맥

하드웨어 문맥 : CPU의 수행 상태를 나타낸다. PC(프로그램 카운터) 값과 각종 레지스터에 저장하고 있는 값들이 여기에 해당한다.

프로세스의 주소공간 : 코드, 데이터, 스택으로 구성되는 프로세스만의 독자적인 주소공간

- 스택 영역 : 원래 함수의 실행 중이던 위치로 돌아가기 위한 복귀주소들을 저장하는 영역
- 데이터 영역 : 전역변수 등의 데이터를 저장하는 영역
- 코드 영역 : 프로그래머가 작성한 코드가 기계어 명령 형태로 저장되는 영역

커널(kernel) 상의 문맥 : 프로세스의 PCB(프로세스 제어 블록)와 커널(kernel) 스택이 해당된다.

이러한 문맥을 가지는 프로세스는 실행이 되면서 상태가 계속 변한다.
그러므로 '프로세스 상태(Process state)' 개념을 알아두어야 한다.

## 프로세스 상태(Process state)

프로세스는 다음 상태 중 하나가 될 수 있다.

- new(새로운)
- running(실행)
- waiting(blocked)(대기)
- ready(준비완료)
- terminated(종료)

![process_state_diagram](/images/operating_system/process_state_diagram.png)

new(새로운) : 프로세스가 생성 중인 상태
(Process를 위한 자료구조는 생성되었지만 메모리 획득은 승인받지 못한 상태)
running(실행 중) : 명령어들을 실행 중인 상태(CPU 점유 상태 / 매시점 하나뿐인 상태)
ready(준비완료) : 프로세스가 CPU를 점유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태
waiting(blocked)(대기) : 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태
terminated(종료) : 프로세스가 종료되었지만 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

하나의 프로세스의 상태가 변화하면서 생길 수 있는 상황을 생각해보자.

![process_state_change](/images/operating_system/process_state_change.png)

1. CPU가 프로세스 A의 PC 값을 하나씩 읽으면서 명령어를 실행한다.
2. 명령을 실행하다가 disk I/O를 만난다. (디스크에서 데이터를 읽어와야 후속 명령이 가능하다.)
3. 프로세스 A는 waiting(blocked) 즉 CPU를 할당해도 명령을 실행할 수 없는 상태로 바뀌고 디스크 장치 큐에 가서 줄을 선다. 그동안 CPU는 다른 준비 상태의 프로세스를 수행한다. (ready -> running)
4. 프로세스 A의 차례가 와서 디스크 컨트롤러로부터 서비스를 받는다. 즉, 디스크 원판에서 데이터를 로컬 버퍼로 옮긴 상태가 된다.
5. 디스크 컨트롤러가 CPU에 interrupt 즉 입출력 완료를 알린다.
6. CPU는 인터럽트 루틴을 수행한다.
   6-1) 사용자 모드에서 커널 모드로 전환한다.
   6-2) 장치 큐에서 Process A를 준비 큐로 옮긴다.
   6-3) 로컬 버퍼에 있는 데이터를 메모리로 옮긴다.
7. 이전 프로세스에 CPU를 다시 할당한다. 커널 모드에서 사용자 모드로 다시 전환된다.
   (경우에 따라 입출력 완료된 프로세스도 CPU 제어권을 이양받을 수 있다.)

이렇게 프로세스의 상태와 문맥은 수시로 바뀐다. 그러므로 운영체제는 이를 관리할 별도의 자료구조가 필요한데 이를 '프로세스 제어 블록(PCB)'라고 한다.

## 프로세스 제어 블록(PCB : Process Control Block)

프로세스 제어 블록(PCB) : 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스당 유지하는 정보들을 담는 커널 내의 자료구조

PCB의 구성요소는,

1. 프로세스 상태
   ready, runnig 등의 프로세스 상태를 나타낸다. CPU 할당 가능여부를 결정하기 위해 필요하다.

2. 프로그램 카운터
   다음에 실행할 명령어 주소를 담고 있다.

3. CPU 레지스터
   현 시점에 레지스터에 어떤 값들이 있는지를 나타낸다.

4. CPU 스케줄링 정보
   프로세스의 우선순위, 스케줄 큐에 대한 포인터 정보를 담는다.

5. 메모리 관리 정보
   base 레지스터, limit 레지스터 등 메모리 할당을 위해 필요한 정보를 말한다.

6. 자원 사용 정보
   CPU 사용시간, 프로세스 번호 등의 정보를 말한다.

7. 입출력 상태 정보
   프로세스에 할당된 입출력 장치들과 열린 파일들의 목록 등을 말한다.

앞서 언급했지만 PCB가 필요한 이유가 바로 '문맥 교환(context switching)'이다. 문맥이 교환되면서 기존 레지스터의 값이 지워지는데 이를 담아두는 것이 PCB다.

## 문맥 교환(context switching)

문맥 교환 : 하나의 사용자 프로세스에서 다른 사용자 프로세스로 CPU의 제어권이 넘어가는 과정

문맥 교환이 일어나는 과정을 예를 들어 생각해보자.

1. 프로세스의 명령을 실행하다가 I/O 요청 명령을 만난다.
2. 수행 중이던 프로세스의 상태는 running에서 ready로 바뀌고 프로세스의 문맥은 자신의 PCB에 저장된다.
3. 새롭게 CPU를 할당받을 프로세스의 상태는 ready에서 running으로 바뀌고 자신의 문맥을 PCB에서 하드웨어로 복원한다.

참고)
running 상태의 Process가 timer 인터럽트 또는 I/O 인터럽트가 아닌 인터럽트 또는 시스템 콜이 호출되는 경우가 있을 수 있다. CPU의 제어권이 운영 체제로 넘어가고 문맥 중 일부를 PCB에 저장하게 된다. 이러한 경우는 실행 모드만 사용자 모드에서 커널 모드로 변경되는 것일 뿐 문맥 교환이라고 하지는 않는다.

위 과정처럼 문맥 교환이 일어날 수 있는데 문맥 교환에 소요되는 시간은 시스템 입장에서 오버헤드다. 시분할 시스템 환경에서 CPU 할당시간이 중요한 이유다.

CPU 할당시간을 너무 짧게 세팅하면 너무 빈번한 문맥 교환이 일어나서 오버헤드가 증가하고,
CPU 할당시간을 너무 길게 세팅하면 시분할 시스템의 의미가 퇴색될 수 있다.

이러한 문맥교환은 사실 빈번할 수 밖에 없다. 시분할 시스템의 목적 자체가 여러 사용자가 상호작용할 수 있도록 하는 것이기 때문이다. 프로세스들 사이에 CPU를 빈번하게 교체해줄 수 밖에 없는 것이다.

그렇다면 CPU는 실행 가능한 여러 프로세스 중 하나를 실행해야 하는데 이렇게 프로세스를 선택하는 것이 '프로세스 스케줄링'이다.

## 프로세스 스케줄링

Process를 스케줄링하기 위해 다양한 Queue들이 존재한다. 하나씩 살펴보도록 하자.

1. 작업 큐(job queue)
   시스템 내의 모든 프로세스를 관리하기 위한 큐다. 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속한다. 착각해서 안 되는 것은 작업 큐에 있다고 반드시 메모리를 가지고 있는 것은 아니라는 것이다.

2. 준비 큐(ready queue)
   CPU를 할당받고 실행되기 위해 기다리고 있는 프로세스들을 관리하기 위한 큐다.

3. 장치 큐(device queue)
   각각의 장치마다 서비스를 기다리며 기다리며 줄 서 있는 프로세스들을 관리하기 위한 큐다.

![queuing_diagram](/images/operating_system/queuing_diagram.png)

프로세스들은 다양한 스케줄링 큐들을 이동하면서 서비스를 받는데 이러한 이동을 결정하는 스케줄러가 존재한다.

스케줄러 : 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 모듈

스케줄러에는 크게 2가지가 있다.

1. 장기 스케줄러(작업 스케줄러 : job scheduler)
2. 단기 스케줄러(CPU 스케줄러)

장기 스케줄러는 프로세스에게 메모리를 할당하는 문제에 관여한다. (CPU에 의해 실행되려면 프로세스가 메모리를 보유해야 한다.)
즉, 시작 상태의 프로세스들 중 어떠한 프로세스들을 큐에 삽입할 것인지를 결정하는 역할을 한다.
이를 통해
(1) 다중 프로그래밍의 정도가 결정되고,
(2) I/O bound process 와 CPU bound process 의 배합이 적절할 수 있도록 결정해야 하므로
상당히 중요한 역할을 수행한다고 볼 수 있다.

한편, 단기 스케줄러는 준비 상태의 프로세스들 중에서 어떤 프로세스를 다음 번에 실행 상태로 만들 것인지를 결정한다.
예를 들어 시분할 시스템에서 timer 인터럽트가 발생하면 단기 스케줄러가 호출된다.

            단기 스케줄러                        장기 스케줄러

실행빈도 밀리세컨드 단위의 매우 빈번한 호출 수십 초 내지 수 분 단위의 호출

수행속도 매우 빨라야 함 상대적으로 속도가 느린 것이 허용됨

그런데 현대의 시분할 시스템 환경에서는 장기 스케줄러를 두지 않는 경우가 대부분이다.
(과거 자원이 빈약해 메모리 보유량이 지나쳐 시스템 효율이 떨어지는 상황을 방지하는 역할을 했다.)
그래서 시작 상태가 되면 곧바로 프로세스에 메모리를 할당해 준비 큐에 넣어준다. 그래도 너무 메모리에 많이 적재되면 당장 필요한 프로세스의 주소공간조차도 메모리에 올려놓기 어려운
상황이 발생하기 때문에 장기 스케줄러 대신 중기 스케줄러를 두는 경우가 많다.

중기 스케줄러 : 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러

중기 스케줄러는 메모리에 올라온 프로세스 중 일부를 선택해 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장한다.

중기 스케줄러(medium term scheduler)에게 swap out되는 0순위는, blocked process다.
당장에 CPU를 획득할 가능성이 없고 그래서 메모리를 보유하는 것도 의미가 없다.

그 다음 1순위는, 타이머 인터럽트로 준비 큐로 이동하는 ready process다. 이유는, 준비 큐에 프로세스가 너무 많으면 개별 프로세스에 배당된 메모리량이 너무 적어진다. 또한, CPU를 다시 할당받을 때까지의 시간이 증가하므로 당장 필요한 프로세스에 메모리를 추가로 부여하는 것이
더욱 효율적이다.

중기 스케줄러가 있는 경우 상태(state)가 하나 더 있다고 볼 수 있는데, 바로 중지(suspended) 상태다. 중지 상태는 디스크로 스왑 아웃된 상태를 말한다. 준비 상태에서 swap out된 경우를 '중지 준비 상태'라고 하고, blocekd 상태에서 swap out된 경우를 '중지 봉쇄 상태'라고 한다.

프로세스 스케줄링에 의해 프로세스의 상태 변화가 일어나는 과정을 살펴봤다. 프로세스 스케줄링이 아니라 프로세스에 대한 연산에 의해서도 프로세스가 동적으로 생성되어 병행 실행되고, 종료됨으로써 프로세스의 상태가 변화할 수 있다.

## 프로세스에 대한 연산

### 프로세스 생성

프로세스는 실행 도중에 프로그램 생성 시스템 콜을 통해 여러 개의 새로운 프로세스를 생성하는 것이 가능하다.
이때 생성하는 프로세스를 부모 프로세스라고 하고, 생성되는 프로세스를 자식 프로세스라고 한다.

각각의 프로세스는 pid 즉 프로세스 식별자에 의해 구분되고 프로세스들의 계층도는 트리의 형태를 띄게 된다.

이렇게 기본적으로 부모 프로세스가 자식 프로세스를 생성하는 방식으로 프로세스가 생성되는데 수행되는 방식에 따라 분류할 수 있다.

1. 자원 공유

- 부모 프로세스와 자식 프로세스가 자원을 공유하는 방식
  이렇게 되면 임의의 프로세스가 너무 많은 서브프로세스를 생성해 시스템이 과부하되는 것을 방지할 수 있다.
- 자원을 공유하지 않는 방식(원칙)
  자식 프로세스가 생성되면 그 때부터는 별도의 프로세스라고 볼 수 있다. 그러므로 일반적으로는 서로 CPU를
  얻기 위해 경쟁하는 모델이 된다.

2. 수행 방식

- 부모 프로세스와 자식 프로세스가 공존하는 모델(병렬 실행)
- 자식 프로세스가 종료될 때까지 부모 프로세스가 기다리는 모델

그렇다면 프로세스가 어떻게 생성되는지 조금 더 자세히 살펴보도록 하자.

#### 프로세스는 어떻게 생성되는가?

1. 복제 생성

프로세스는 대개 복제 생성된다. 프로세스 생성은 사용자 프로세스가 직접 할 수 없기 때문에 OS를 통해서만 가능하다.
그래서 fork()라는 시스템 콜을 통해 주소와 PCB 등의 자료구조를 복제 생성한다.

복제 생성한다는 말은 문맥을 복사한다는 말로 이해하면 된다. 즉, 주소공간과 PC, 레지스터 값들이 복사된다.

다음의 코드를 살펴보면서 fork() 의 과정을 이해해보자. 두 개의 동일한 코드를 두고 생각하면 이해가 더욱 쉽다.
fork() 시스템 콜을 만나면 자식 프로세스가 생성된다. 자식 프로세스는 문맥을 그대로 복사하기 때문에 PC 값은 fork()를 호출한 다음을 가리키고 있어야 한다. 즉, fork() 다음 코드부터 실행하게 된다.

문제는 문맥을 복사하기 때문에 같은 코드를 가지고 있고 복제본이면서 스스로 원본이라고 생각하는 셈이 되어 버린다.
그래서 부모 프로세스와 자식 프로세스를 구분할 수 있어야 하는데 부모 프로세스는 fork의 결과값이 양수이고, 자식 프로세스는 결과값이 0이 된다. 이를 통해 올바른 제어 흐름을 찾아간다.

부모 프로세스

```c
#include <stdio.h>

main(int argc, char *argv[])
{
    int pid;
    /* 새 프로세스를 생성한다.(fork) */
    pid = fork();

    if (pid < 0) { /* 오류 발생 */
        fprintf(stderr, "Fork Failed");
        exit(-1);
    }
    else if (pid == 0){ /* 자식 프로세스 */
        execlp("/bin/ls", "ls", NULL);
    }
    else { /* 부모 프로세스 */
        /* 부모가 자식이 완료되기를 기다릴 것임 */
        wait(NULL);
        printf("Child Complete");
        exit(0);
    }
}
```

자식 프로세스

```c
#include <stdio.h>

main(int argc, char *argv[])
{
    int pid;
    /* 새 프로세스를 생성한다.(fork) */
    pid = fork();

    if (pid < 0) { /* 오류 발생 */
        fprintf(stderr, "Fork Failed");
        exit(-1);
    }
    else if (pid == 0){ /* 자식 프로세스 */
        execlp("/bin/ls", "ls", NULL);
    }
    else { /* 부모 프로세스 */
        /* 부모가 자식이 완료되기를 기다릴 것임 */
        wait(NULL);
        printf("Child Complete");
        exit(0);
    }
}
```

참고로 초반에는 주소공간 등을 부모 프로세스와 자식 프로세스가 공유하게 된다. 같은 내용인데 새로운 공간을 할당하면 메모리 낭비인 셈이다. 그래서 가능한 공유할 수 있는 것은 공유하면서 시작한다. 그런데 자식 프로세스와 부모 프로세스는 자식 프로세스가 생성되고부터는 별개의 프로세스이기 때문에 내용이 달라질 수 있다. stack에 쌓이는 내용도 달라지고 결국 각자의 길을 가게 된다. 이 때 복사를 한다. 이러한 기법을 'copy on write' 기법이라고 한다. 즉, write가 발생했을 때 그 때 copy를 하겠다는 의미다.

2. 새로운 프로세스를 덮어씀

일단 프로세스가 복제 생성되면 exec() 시스템 콜을 통해 새로운 프로그램을 적재시킨다. exec() 시스템 콜을 호출하면 다른 함수의 제어 흐름으로 넘어간다고 생각하면 이해가 쉽다. 주의할 것은 exec()을 호출하면 되돌아갈 수 없다. 제어흐름이 완전히 넘어간다. 또 꼭 자식 프로세스를 만들어서 해야 하는 것은 아니지만 프로세스가 생성될 때 exec() 시스템 콜을 호출하는 방식으로 프로세스가 생성된다.

### 프로세스 종료

프로세스가 마지막 문장의 실행을 끝내고, exit() 시스템 콜을 호출하면 운영체제에게 자신의 제거를 요청하면서 종료된다. exit을 명시해주지 않으면 compiler가 컴파일하면서 마지막 수행위치에 exit을 삽입한다고 생각하면 된다.

프로세스 종료에서 원칙은 자식 프로세스가 먼저 종료되어야 한다는 것이다. 그러므로 자식 프로세스가 강제로 종료되는 경우도 있다.

- 자식이 할당 자원의 한계치를 넘어서는 경우
- 자식에게 할당된 태스크가 더 이상 필요하지 않은 경우
- 부모 프로세스가 종료되는 경우, 자식 프로세스를 다 종료하고 종료된다.

위 모델에서 봤듯이 자식 프로세스가 종료되는 것을 부모 프로세스가 기다리는 방식이라면 wait() 시스템 콜을 호출하여 부모 프로세스는 running에서 blocked 상태로 전환되고 자식 프로세스가 종료될 때까지 blocked 상태로 있다가 자식 프로세스가 종료되면 kernel에 의해 다시 깨어난다.
예를 들어 리눅스에서 명령어를 쳤을 때도 wait() 시스템 콜이 호출된다고 생각하면 된다. 터미널도 하나의 프로그램이고, 입력하는 명령어를 통해 자식 프로세스를 생성하는 셈이다.

## 프로세스간 통신

프로세스가 동적으로 생성되어 병렬적으로 실행 가능하다는 것을 알아봤는데 이 프로세스들간의 상호작용을 하는 경우도 충분히 가능하다.
이를 통해 정보를 공유할 수 있고, 특정 태스크를 서브태스크로 나누어 병렬 실행해 특정 태스크를 빠르게 실행하는 것도 가능하다.

그런데 원칙적으로 프로세스는 서로 독립적이다. 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다. 프로세스 각각이 독자적인 주소공간을 가지고 서로 이 영역을 침범할 수 없다.

그래서 필요한 것이 프로세스간 협력 메커니즘(IPC: Interprocess Communication)이다.
이 IPC에는 2가지 방법이 있는데 'message passing' 과 'shaerd memory'이다.

![interprocess_communication](/images/operating_system/interprocess_communication.png)

- message passing : 커널을 통해 메세지를 전달하는 방식이다.
  - 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환하는 데 유용하다.
  - 공유 메모리 모델보다 구현이 쉽다.
- shared memory : 서로 다른 프로세스 간에 일부 주소공간을 공유하는 방식이다.
  - 메세지 전달 기법은 시스템 호출을 사용하여 구현되므로 커널 간섭 등의 시간이 소모되는 작업들을 부가적으로 수행해야 하므로 공유 메모리 모델이 메세지 전달 기법보다 빠르다.
  - 공유 메모리 영역이 구축되면 모든 접근은 메모리 접근과 동일하게 처리되므로 커널의 도움이 필요 없다.

먼저 메세지 패싱 기법이다.

1. Message Passing

기본적으로 제공되는 연산은 send와 receive 연산이다. 메세지 전달 기법에는 2가지 방법이 있다.

1-1) Direct Communication

통신하려는 프로세스의 이름을 명시적으로 표시하는 방식이다.

Process P -> Process Q

Send(Q, message)
Receive(P, message)

1-2) Indirect Communication

mailbox 또는 port 를 통해 메세지를 간접 전달하는 기법이다.

Process P : Send(M, message) -> Mailbox M -< Process Q : Receive(M, message)

2. Shared memory

이후 커널 간섭이 없다고 하지만 이 역시도 처음엔 커널의 시스템 콜을 통해 공유할 공간을 매핑해두어야 한다. 그리고 커널이 한 번 공간을 배정해놓으면 사용자 프로세스간 통신을 하는 방식이다.
