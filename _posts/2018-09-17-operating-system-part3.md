---
layout: post
subclass: post
title: "운영체제 (3) 스레드(Threads)"
date: 2018-09-17 00:00:03
tags: [dudaji, computer-science, operating_system]
excerpt: "운영체제 Threads에 대한 정리입니다."
disqus: True
---

## 스레드란?

스레드 : CPU 이용의 기본 단위

프로세스 내부에 CPU 수행 단위가 여러 개 있을 때 그것을 '스레드(Thread)'라고 한다.

## 스레드는 왜 필요한가?

![process_initialization](/images/operating_system/process_initialization.png)

프로세스가 하나 생성되면 위 그림과 같이 주소공간이 생성되고 프로세스 제어 블록(PCB)가
생성된다. 그런데 동일한 일을 하는 프로세스가 여러 개라면? 주소공간과 프로세스 제어 블록이
여러 개가 생성되어 메모리 낭비라고 볼 수 있다. 프로세스 생성 작업은 매우 많은 시간을 소모하고 많은 자원을 필요로 하는 일이다. 새 프로세스와 기존 프로세스가 하는 일이 크게 다르지 않으면 이러한 오버헤드를 굳이 감수할 필요가 없다.

스레드의 개념은 동일한 일을 하는 프로세스가 여러 개 있다면 주소공간을 하나만 만들고 프로세스마다 다른 영역의 코드를 실행할 수 있게 하는 것이다. 즉, 프로세스 하나에 CPU 수행 단위를 여러 두는 것이다.

![thread_initialization](/images/operating_system/thread_initialization.png)

위 그림과 같이 공유할 수 있는 것은 최대한 공유하고 CPU 수행과 관련된 것들만 별도로 두는 것이다. 예를 들어 code의 어떤 영역을 실행할 것인지를 결정하기 위해 별도의 PC 값과 register 값을 가진다. 또한, 각 스레드에서 별도의 영역을 실행하다가 함수를 호출한다면 원래의 제어 흐름으로 돌아갈 수 있어야 하기 때문에 복귀 주소를 저장할 스택 영역을 별도로 둔다.

그러므로 스레드가 개별적으로 가지는 것은

- Program counter
- Register set
- Stack space

공유하는 부분은

- code section
- data section
- OS resources
  로 볼 수 있다.

스레드는 프로세스와 비교했을 때 위와 봤듯이 공유할 수 있는 것은 최대한 공유해서 상대적으로 오버헤드를 줄일 수 있기 때문에 lightweight process라고 말하고 프로세스는 상대적으로 자원을 많이 사용하기 때문에 heavyweight process라고 불린다.

그렇다면 자원 공유를 통한 오버헤드 감소와 더불어 프로세스 대신 스레드를 두었을 때 장점은 무엇일까?

## 스레드의 장점

1. 응답성(Responsiveness)

스레드를 두면 하나의 스레드가 blocked 상태여도 동일한 task 내 다른 스레드가 running 되어서 빠른 처리가 가능하다. 그러므로 응답성이 개선이된다.

2. 자원 공유(Resource Sharing)

앞서 살펴봤듯이 자원 공유를 통한 자원 절약이 가능하다.

3. 경제성(Economy)

프로세스를 하나 생성하는 것은 오버헤드가 상당히 큰 작업이다. 그와 더불어 문맥 교환 시의 오버헤드 역시 스레드에 비해 프로세스의 오버헤드가 크다. 하지만 스레드의 문맥 교환 시 오버헤드는 상대적으로 그렇게 크지 않다. Unix의 일종인 Solaris 운영체제의 경우 Process 생성은 30배, 문맥 교환은 5배의 성능 차이를 보였다. 동일한 일을 수행하는 것이라면 가능하면 스레드를 두는 것이 경제적이고 수행속도도 향상될 수 있다.

4. 멀티 프로세서 구조의 활용

멀티 스레드의 이점은 멀티 프로세서 구조에서 더욱 증가한다. 멀티 프로세서 구조에서는 각각의 스레드가 다른 프로세서에서 병렬적으로 실행될 수 있기 때문이다. 단일 스레드 구조의 프로세스는 CPU가 아무리 많아도 단 하나의 CPU에서만 실행된다. 멀티 프로세서에서 다중 스레드 구조를 가지고 가면 병렬성이 증가된다.

## 다중 스레드 모델

스레드에는 두 가지 형태가 있는데 하나는 '사용자 수준 스레드'이고, 또 다른 하나는 '커널 수준 스레드'이다. 사용자 수준 스레드는 커널 위에서 지원되며 커널의 지원 없이 관리된다. 커널의 입장에서는 다중 스레드라는 것을 모르는 것이다. 반면에 커널 수준 스레드는 운영체제에 의해 지원되고 관리된다. OS가 스레드가 여러 개라는 것을 인식하고 있는 것이다.

다중 스레드 모델에는 3가지 모델이 있다.

![multi_threading_model](/images/operating_system/multi_threading_model.png)

1. 다 대 일 모델(Many to One Model)

많은 사용자 수준 스레드가 하나의 커널 스레드에 매핑된다. 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 이루어진다. 따라서 커널의 지원을 받지 않아도 되기 때문에 상대적으로 빠르다고 할 수 있지만 한 스레드가 시스템 콜을 호출할 경우 전체 프로세스가 blocked 상태가 된다. 또한, 한 번에 하나의 스레드만이 커널에 접근할 수 있기 때문에 멀티 프로세서에서도 병렬적으로 동작할 수 없다.

2. 일 대 일 모델(One to One Model)

하나의 사용자 수준 스레드가 하나의 커널 스레드에 연결된다. 하나의 스레드가 시스템 콜을 호출하더라도 다른 스레드가 실행될 수 있기 때문에 다 대 일 모델보다 높은 병렬성을 제공한다. 이 모델에서는 멀티 프로세서에서 다중 스레드가 병렬적으로 실행되는 것을 허용한다.

이 모델의 단점은 하나의 사용자 수준 스레드가 생성될 때마다 커널 수준 스레드가 생성되기 때문에 커널 스레드를 생성되는 오버헤드로 인해 응용 프로그램의 성능이 저하될 수 있다는 점이다.

3. 다 대 다 모델(Many to Many Model)

다 대 일 모델의 문제점은 하나의 스레드만이 커널에 의해서 스케줄되기 때문에 진정한 동시성을 획득할 수 없다는 것이었고 일 대 일 모델은 프로그래머가 한 응용 내에 너무 많은 스레드를 생성하지 않도록 주의해야 한다는 점이 문제였다.

다 대다 모델은 프로그래머가 필요로 하는 만큼의 많은 사용자 스레드가 그 수에 상응하는 커널 스레드와 연결되어 멀티 프로세서 환경에서 병렬로 실행하는 것이 가능하다. 이렇게 되면 스레드가 시스템 콜을 호출하더라도 다른 스레드의 실행을 스케줄링할 수 있다.
